# Как работает тестовый фреймворк на ruby

## Шаг 1

### Так обычно выглядит тестовый файл

```ruby
require "jinitest"

class Ex1Test < JiniTest::Test
  def test_foo
    assert calculated, expected
  end
end
```

В чем суть тестового фреймворка?
Тестовый файл наследуется от класс фреймворка.
Фреймворк создает инстанс класса теста, вызывает тестовые методы и возвращает отчет.

Для начала нам надо сделать так, чтобы `JiniTest::Test` создал инстанс нашего класса.
Для этого надо, чтобы он как-то узнал название нашего класса `Ex1Test`.
В ruby есть такой хук `self.inherited(childClass)`.
И это круто.
В этом методе мы могли бы все сделать, т.е. создать инстанс класса `Ex1Test`, найти имена методов, начинающихся с слова test и вызвать их, а потом и отчет вывести.

Но... обычно тестовых классов много и в таком случае отчеты будут выводится после вызова всех методов тестового класса, а нам бы хотелось единый отчет после вызова всех тестовых классов. Значит надо сначала где-то сохранить имена тестовых классов, а потом в цикле их вызывать и уже после этого показать обобщенный отчет.
Т.к. все тестовые классы наследуются от класса `JiniTest::Test`, будем сохранять в переменную класса `@@runnables = []`, которая будет являтся массивом.

Выглядит так:
```ruby
def self.inherited(klass)
  self.runnables << klass
end
```

Ок. С этим разобрались. Но нам нужен какой-то верхнеуровневый модуль, который пройдется по массиву и сделает всю работу, после того как все тестовые классы будут определены.
И вот для этого, в модуле `JiniTest` у нас есть вызов метода модуля `JiniTest.autorun`.
Но он срабатывает в самом начале, один раз когда интерпретатор ruby встречает `require 'jinitest'`.
И проблема тут в том, что сначала вызывается -> выполняется -> звершается функция `JiniTest.autorun`, а уже потом вызывается хук `self.inherited(childClass)` и заполняется массив `@@runnables = []`. Далее звершается вся наша программа.

И вот тут еще один трюк:
```ruby
def self.autorun
  at_exit {
    JiniTest.run
  }
end
```

Функция ядра `at_exit` выполнится, когда будет происходить выход из программы. Собственно эта функция принимает блок и выполняет его.
И не забываем, что блок можно определить либо так
```ruby
do |arg|
end
```
либо так
```ruby
{ |arg| do_something }
```
В нашем случае просто блок без аргументов. Вот в этом и самая соль. T.е. перед завершением программы начинает выполнятся основная логика тестового фреймворка.

Запустить тест для одного файла можно так:
```bash
ruby -I./lib ./test.rb
```

## Шаг 2

### Хочется запускать всю пачку тестов из папки `test`

Самый простой способ сделать это, установить гем `rake`. Это такой швейцарский нож, который умеет разное, в частности он из коробки умеет запускать тесты.
Что значит запускать тесты? По сути это значит добавить пути к директориям `test`, `lib` в специальную переменную `$LOAD_PATH` и запустить по очереди все файлы в директории `test`.

Когда мы установим гем `rake` он создаст свой файл в системной директории с бинарниками и мы получим возможность в командной строке сделать так:

```bash
rake
```

Далее нужно в корневой директории этого проекта создать файл `Rakefile`:
```ruby
require "rake/testtask"

Rake::TestTask.new(:test) do |t|
  t.libs << "test"
  t.libs << "lib"
  t.test_files = FileList["test/**/*_test.rb"]
end
```

Теперь мы можем сделать так:
```bash
rake test
```

Здесь задается название задачи:
```ruby
Rake::TestTask.new(:test) do |t|
```

Тут задаются какие директории добавить в `#LOAD_PATH` и название директории с тестами:
```ruby
  t.libs << "test"
  t.libs << "lib"
  t.test_files = FileList["test/**/*_test.rb"]
```

