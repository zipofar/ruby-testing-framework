# Как работает тестовый фреймворк на ruby

## Шаг 1

### Так обычно выглядит тестовый файл

```
require "minitest"

class TestMeme < MiniTest::Test
  def test_foo
    assert calculated, expected
  end
end
```

В чем суть тестового фреймворка?
Тестовый файл наследуется от класс фреймворка.
Фреймворк создает инстанс класса теста, вызывает тестовые методы и возвращает отчет.

Для начала нам надо сделать так, чтобы `MiniTest::Test` создал инстанс нашего класса.
Для этого надо, чтобы он как-то узнал название нашего класса `TestMeme`.
В ruby есть такой хук `self.inherited(childClass)`.
И это круто.
В этом методе мы могли бы все сделать, т.е. создать инстанс класса TestMeme, найти имена методов, начинающихся с слова test и вызвать их, а потом и отчет вывести.

Но... обычно тестовых классов много и в таком случае отчеты будут выводится после вызова всех методов тестового класса, а нам бы хотелось единый отчет после вызова всех тестовых классов. Значит надо сначала где-то сохранить имена тестовых классов, а потом в цикле их вызывать и уже после этого показать обобщенный отчет.
Т.к. все тестовые классы наследуются от класса `MiniTest::Test`, будем сохранять в переменную класса `@@runnables = []`, которая будет являтся массивом.

Выглядит так:
```
def self.inherited(klass)
  self.runnables << klass
end
```

Ок. С этим разобрались. Но нам нужен какой-то верхнеуровневый модуль, который пройдется по массиву и сделает всю работу, после того как все тестовые классы будут определены.
И вот для этого, в модуле `MiniTest` у нас есть вызов метода модуля `MiniTest.autorun`.
Но он срабатывает в самом начале, один раз когда интерпретатор ruby встречает `require 'minitest'`.
И проблема тут в том, что сначала вызывается -> выполняется -> звершается функция `MiniTest.autorun`, а уже потом вызывается хук `self.inherited(childClass)` и заполняется массив `@@runnables = []`. Далее звершается вся наша программа.

И вот тут еще один трюк:
```
def self.autorun
  at_exit {
    MiniTest.run
  }
end
```

Функция ядра `at_exit` выполнится, когда будет происходить выход из программы. Собственно эта функция принимает блок и выполняет его.
И не забываем, что блок можно определить либо так
```
do |arg|
end
```
либо так
```
{ |arg| do_something }
```
В нашем случае просто блок без аргументов. Вот в этом и самая соль. T.е. перед завершением программы начинает выполнятся основная логика тестового фреймворка.


## Start test
```bash
ruby -I./lib ./test.rb
```
